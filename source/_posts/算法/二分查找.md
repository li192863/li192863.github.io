---
title: 二分查找
categories: '算法'
tags: ['查找', '二分']
date: 2024-07-18 20:40:26
---
## 二分查找

### 代码模板

以下描述中，0表示假、1表示真。

要点如下：

* 模板采用闭区间查找，`left`和`right`分别是为区间左右端点，循环条件为`left < right`。
* 中点计算方式为`left + (right - left + 1 >> 1)`或`left + (right - left >> 1)`。
* `check(nums[i])`全0时退化、`left = right`且均存在于闭区间。

方法如下：

1. 确定`check`函数、保证二段性(左0右1/左1右0)。

* 左0右1查找左边界、左1右0查找右边界。
* `check`可视为`check(nums[i])`，`check`更新区间时为`check(nums[mid])`。
* 函数返回`check`为真的中间边界、退化情况下返回1的边界。

2. check为真时，左边界模板调整右、右边界模板调整左；check为假时，需要保证闭区间、保证不重叠、保证不遗漏。

* `check`为真`left`或`right`调整为`mid`，**若调整`left`则计算`mid`时需加1（`int mid = left + (right - left + 1 >> 1)`）**。
* `check`为假`left`或`right`需保证区间不交叉。

代码如下：

* 二分查找左边界：多值相同返回左边界。

```java
public int binarySearchLeft(int[] nums, int target) { // [left, right]区间内查找check(nums)==true左边界
    int left = 0, right = nums.length - 1;

    while (left < right) {
        int mid = left + (right - left >> 1); // 当check(mid)真调整的是right时计算mid的方式应该为 m=l+r>>1
        if (check(nums[i])) { // check(nums[i]) == [0, 0,...,0, 1, 1,...,1]，常为num[mid] >= target
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left; // left == right，且nums[left] >= target（[check为真]左边界）
}
```

* 二分查找右边界：多值相同返回右边界，调整`left`时算`mid`加1。

```java
public int binarySearchRight(int[] nums, int target) { // [left, right]区间内查找check(nums)==true右边界
    int left = 0, right = nums.length - 1;

    while (left < right) {
        int mid = left + (right - left + 1 >> 1); // 当check(mid)真调整的是left时计算mid的方式应该为 m=l+r+1>>1
        if (check(nums[i])) { // check(nums[i]) == [1, 1,...,1, 0, 0,...,0]，常为num[mid] <= target
            left = mid;
        } else {
            right = mid - 1;
        }
    }

    return left; // left == right，且nums[left] <= target（[check为真]右边界）
}
```

* 浮点二分查找

```java
public double folatBinarySearch(double left, double right) {
    const double eps = 1e-6; // eps表示精度，取决于对精度的要求
    while (right - left > eps) {
        double mid = (left + right) / 2;
        if (check(mid)) { // check([left, right])左0右1，常为f[mid] >= target
            right = mid;
        } else {
            left = mid;
        }
    }
    return left;
}
```

### 实际应用

* [在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        if (nums.length == 0) {
            return new int[] {-1, -1};
        }
        return new int[] {binarySearchLeft(nums, target), binarySearchRight(nums, target)};
    }

    public int binarySearchLeft(int[] nums, int target) { // [lo, hi]区间内查找check(nums)==true左边界
        int left = 0, right = nums.length - 1;

        while (left < right) {
            int mid = left + (right - left >> 1); // 当check(mi)真调整的是right时计算mid的方式应该为 m=l+r>>1
            if (nums[mid] >= target) { // check(nums[i]) == [0, 0,...,0, 1, 1,...,1]，常为num[mid] >= target
                right = mid;
            } else {
                left = mid + 1;
            }
        }

        return nums[left] != target ? -1 : left; // left == right，且nums[left] >= target（[check为真]左边界）
    }

    public int binarySearchRight(int[] nums, int target) { // [lo, hi]区间内查找check(nums)==true右边界
        int left = 0, right = nums.length - 1;

        while (left < right) {
            int mid = left + (right - left + 1 >> 1); // 当check(mid)真调整的是left时计算mid的方式应该为 m=l+r+1>>1
            if (nums[mid] <= target) { // check(nums[i]) == [1, 1,...,1, 0, 0,...,0]，常为num[mid] <= target
                left = mid;
            } else {
                right = mid - 1;
            }
        }

        return nums[left] != target ? -1 : left; // left == right，且nums[left] <= target（[check为真]右边界）
    }
}
```

* [寻找峰值](https://leetcode.cn/problems/find-peak-element/description/)

```java
class Solution {
    public int findPeakElement(int[] nums) {
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left >> 1);
            if (nums[mid] > nums[mid + 1]) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
}
```

* [搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/)

```java
class Solution {
    public int search(int[] nums, int target) {
        int idx = binarySearch(nums, 0, nums.length - 1);
        if (nums[0] <= target) {
            return binarySearch(nums, 0, idx, target);
        } else {
            // if (idx + 1 > nums.length - 1) return -1;
            return binarySearch(nums, idx + 1, nums.length - 1, target);
        }
    }

    private int binarySearch(int[] nums, int left, int right) { // [left, right]
        // nums[0] <= nums[i] 111000
        while (left < right) {
            int mid = left + (right - left + 1 >> 1);
            if (nums[0] <= nums[mid]) { // [m, r]
                left = mid;
            } else { // [l, m - 1]
                right = mid - 1;
            }
        }
        return nums[0] > nums[left] ? -1: left;
    }

    private int binarySearch(int[] nums, int left, int right, int target) { // [left, right]
        // nums[i] >= target 000111
        if (left > right) return -1;
        while (left < right) {
            int mid = left + (right - left >> 1);
            if (nums[mid] >= target) { // [left, mid]
                right = mid;
            } else { // [mid + 1, right]
                left = mid + 1;
            }
        }
        return nums[left] == target ? left : -1;
    }
}
```

* [搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/description/)

```java
class Solution {
    public boolean search(int[] nums, int target) {
        int left = 0, right = nums.length - 1;

        // 恢复二段性
        while (left < right && nums[0] == nums[right]) {
            right--;
        }

        // 二分查找找旋转点
        while (left < right) {
            int mid = left + (right - left + 1 >> 1);
            if (nums[0] <= nums[mid]) {
                left = mid;
            } else {
                right = mid - 1;
            }
        } // left == right, nums[0] <= nums[left]

        // System.out.println(left + " " + right);

        // 搜索左半区间
        if (binarySerach(nums, target, 0, left)) {
            return true;
        }
        // 搜索右半区间，需注意left + 1可能越界
        if (left + 1 <= nums.length - 1 && binarySerach(nums, target, left + 1, nums.length - 1)) {
            return true;
        }
        return false;
    }

    public boolean binarySerach(int[] nums, int target, int left, int right) {
        while (left < right) {
            int mid = left + (right - left >> 1);
            if (nums[mid] >= target) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return nums[left] == target;
    }
}
```